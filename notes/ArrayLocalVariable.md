## ArrayLocalVariable.c

### Source Code:

```c
short main() {
    short a;
    int b[6];
    long long c;
    a = 0xbabe;
    c = 0xba1b0ab1edb100d;
    b[1] = a;
    b[4] = b[1] + c;
    return b[4];
}
```

### Disassembly:

#### Frame 1: ArrayLocalVariable.exe!main(...)
```assembly
sub rsp, 38h
mov eax, 0FFFFBABEh
mov word ptr [rsp], ax
mov rax, 0BA1B0AB1EDB100Dh
mov qword ptr [rsp+8], rax
mov eax, 4
imul rax, rax, 1
movsx ecx, word ptr [rsp]
mov dword ptr [rsp+rax+10h], ecx
mov eax, 4
imul rax, rax, 1
movsxd rax, dword ptr [rsp+rax+10h]
add rax, qword ptr [rsp+8]
mov ecx, 4
imul rcx, rcx, 4
mov dword ptr [rsp+rcx+10h], eax
mov eax, 4
imul rax, rax, 4
movzx eax, word ptr [rsp+rax+10h]
add rsp, 38h
ret
```

## Analyzing the stack

<i><b>Undef</b> just means that it's a padding/filler for a stack</i>

|Address|Value|
|-------------|-------------|
|0x000000000014FE08|0000000140001379 -> RETURN ADDRESS to `ArrayLocalVariable.exe!invoke_main(void)`|
|0x000000000014FE00|16-byte-stack-alignment-padding|
|0x000000000014FDF8|undef|
|0x000000000014FDF0|008425091EDACACB|
|0x000000000014FDE8|undef|
|0x000000000014FDE0|FFFFBABE00000000|
|0x000000000014FDD8|0BA1B0AB1EDB100D|
|0x000000000014FDD0|000000010000BABE|

## Breaking down each statements

<i>By setting the breakpoint at `main()`, the current RSP 000000000014FE08 contains an address value which returns back to `ArrayLocalVariable.exe!invoke_main(void)`.</i>

### Frame 1: ArrayLocalVariable.exe!main(...)

`sub rsp, 38h`
 - `rsp`: 000000000014FE08 - 38 = 0x000000000014FDD0

`mov eax, 0FFFFBABEh`
 - Moves 0xFFFFBABE into `rax` register

`mov word ptr [rsp], ax`
 - Moves 0xBABE into `rsp` register or 0x000000000014FDD0

`mov rax, 0BA1B0AB1EDB100Dh`
 - Moves 0xBA1B0AB1EDB100D into `rax` register

`mov qword ptr [rsp+8], rax`
 - Moves 0xBA1B0AB1EDB100D into `rsp` register or 0x000000000014FDD8

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 1`
 - `rax`: 4 * 1 = 4

`movsx ecx, word ptr [rsp]`
 - Moves 0xBABE into `rcx` register and extending it with F's. Keep in mind that this is `ecx` so it would just extend the half of the value which will be 0xFFFFBABE

`mov dword ptr [rsp+rax+10h], ecx`
 - Moves 0xFFFFBABE into `rsp` register or `0x000000000014FDE4`

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 1`
 - `rax`: 0x4 * 0x1 = 0x4

`movsx rax, dword ptr [rsp+rax+10h]`
 - Moves 0x000000000014FDE4 or 0xFFFFBABE into `rax` register and extending the value with F's
 - `rax`: 0xFFFFFFFFFFFFBABE

`add rax, qword ptr [rsp+8]`
 - Adds 0BA1B0AB1EDB100D and FFFFFFFFFFFFBABE
 - `rax`: BA1B0AB1EDACACB

`mov ecx, 4`
 - Moves `0x4` into rax register

`imul rax, rax, 4`
 - `rax`: 0x4 * 0x4 = 0x10

`mov dword ptr [rsp+rcx+10h], eax`
 - Moves 0x1EDACACB into `rsp` or `0x000000000014FDF0`

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 4`
 - `rax`: 0x4 * 0x4 = 0x10

`movzx eax, word ptr [rsp+rax+10h]`
 - Moves 0xCACB into `rax` register and extending the value with 0's
 - `rax`: 0x00000000000000CACB

`add rsp, 38h`
 - `rsp`: 0x000000000014FDD0 + 38 = 0x000000000014FE08

 `ret`
  - Returns and continues the statement at `ArrayLocalVariable.exe!invoke_main(void)`
  - `rsp`: 000000000014FE08 + 8 = 000000000014FE10
<hr>