## ArrayLocalVariable2.c

### Source Code:

```c
short main() {
  int a;
  short b[64] = {0};
  a = 0x5eaf00d;
  b[1] = (short)a;
  return b[1];
}
```

### Disassembly:

#### Frame 1: ArrayLocalVariable2.exe!main(...)
```assembly
push rdi
sub rsp, 90h
lea rax, [rsp+10h]
mov rdi, rax
xor eax, eax
mov ecx, 80h
rep stos byte ptr[rdi]
mov dword ptr [rsp], 5EAF00Dh
mov eax, 2
imul rax, rax, 1
movzx ecx, word ptr [rsp]
mov word ptr [rsp+rax+10h], cx
mov eax, 2
imul rax, rax, 1
movzx eax, word ptr [rsp+rax+10h]
add rsp, 90h
pop rdi
ret
```

## Analyzing the stack

|Address|Value|
|-------------|-------------|
|0x000000000014FE08|0000000140001369 -> RETURN ADDRESS to `ArrayLocalVariable2.exe!invoke_main(void)`|
|0x000000000014FE00|16-byte-stack-alignment-padding|
|0x000000000014FDF8|0000000000000000 -> (End of `repstos`)|
|0x000000000014FDF0|0000000000000000|
|0x000000000014FDE8|0000000000000000|
|0x000000000014FDE0|0000000000000000|
|0x000000000014FDD8|0000000000000000|
|0x000000000014FDD0|0000000000000000|
|0x000000000014FDC8|0000000000000000|
|0x000000000014FDC0|0000000000000000|
|0x000000000014FDB8|0000000000000000|
|0x000000000014FDB0|0000000000000000|
|0x000000000014FDA8|0000000000000000|
|0x000000000014FDA0|0000000000000000|
|0x000000000014FD98|0000000000000000|
|0x000000000014FD90|0000000000000000|
|0x000000000014FD88|00000000f00d0000|
|0x000000000014FD80|0000000000000000 -> (Entry of `repstos`)|
|0x000000000014FD78|00007ffd6ecf9373|
|0x000000000014FD70|0000000005eaf00d -> Declared 0x5eaf00d|

## Breaking down each statements

### Frame 1: ArrayLocalVariable2.exe!main(...)

`push rdi`
 - `rsp`: 000000000014FE08 - 8 = 000000000014FE00
 - Current value of `rsp`: 0000000000000000

`sub rsp, 90h`
 - `rsp`: 000000000014FE00 - 90 = 000000000014FD70

`lea rax, [rsp+10h]`
 - Copies the stack's address that has an offset of +10h
 - New `rax` value: 0x000000000014FD80

`mov rdi, rax`
 - Moves the value of `rax` into `rdi` register
 - New `rax` value: 0x000000000014FD80

`xor eax, eax`
 - Zeroes/Clears out the `rax` register value

`mov ecx, 80h`
 - Moves 0x80 into ecx

`rep stos byte ptr [rdi]`
 - Decreases `rcx` value by 1, it will proceed to the next instruction once this register is 0
 - Decreases `rdi` value



`mov dword ptr [rsp], 5EAF00Dh`
 - Moves 0x5eaf00d into `rsp` register

`mov eax, 2`
 - Moves 0x2 into `rsp` register

`imul rax, rax, 1`
 - Performs `imul` operand on `rax` register
 - 0x2 * 0x1 = 0x2
 - New value of `rcx`: 0000000000000002

`movzx ecx, word ptr [rsp]`
 - Moves `rsp` value into `rcx` register with zero extended 
 - New value of `rcx`: 000000000000F00D

`mov word ptr [rsp+rax+10h], cx`
 - Moves `rcx` into `rsp` register with an offset of 12

`mov eax, 2`
 - Moves 0x2 into `rax` register

`imul rax, rax, 1`
 - Performs `imul` operand on `rax` register
 - 0x2 * 0x1 = 0x2
 - New value of `rcx`: 0000000000000002

`movzx eax, word ptr [rsp+rax+10h]`
 - Moves the value of `rsp` with an offset of 12 into `rax` register

`add rsp, 90h`
 - `rsp`: 000000000014FD70 + 90 = 000000000014FE00

`pop rdi`
 - `rsp`: 000000000014FE00 - 8 = 000000000014FE08
 - Current value of `rdi`: 0000000000000000

 `ret`
  - Returns and continues the statement at `ArrayLocalVariable2.exe!invoke_main(void)`
  - `rsp`: 000000000014FE08 + 8 = 000000000014FE10
<hr>