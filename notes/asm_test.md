### TEST - Logical Compare

`TEST [reg/mem], [reg/imm]`

Computes the bit-wise AND of first operand (source 1 operand) and the second operand (source 2 operand) and sets the SF, ZF, and PF status flags according to the result.

Like CMP - sets flags, and throws away the result

E.g.

`TEST al, bl` - Performs a bitwise boolean `AND` but it doesn't set the answer in the destination, it just sets the flag.

|Operand|Bits|
|-------------|-------------|
|AL|0010 1011|
|BL|1101 1010|
|Result|0000 1010|

#### Signed Flag (SF)

The SF would be true or set to 1 if both al and bl are negative

Assembly Code

```assembly
test al, bl
js BothNegative
```

**E.g. 1**

|Operand|Bits|
|-------------|-------------|
|AL|1001 1010|
|BL|1101 0110|
|Result|1001 0000|

**SF = 1**

-----------------

**E.g. 2**

|Operand|Bits|
|-------------|-------------|
|AL|1001 1010|
|BL|0101 0110|
|Result|0001 0000|

**SF = 0**

*In this case, the jump here is not taken*

-----------------

#### Parity Flag (PF)

The PF is gonna be a 1 if there's even 1s in the answer and its gonna be a 0 if there's odd 1s in the answer.

Assembly Code

```assembly
test al, bl
jpe EvenPar
```

**E.g. 1**

|Operand|Bits|
|-------------|-------------|
|AL|0110 1110|
|BL|1101 0110|
|Result|0100 0110|

**PF = 0**

*In this case, there's 3 counts of 1 in the result. Therefore the PF is set to 0*

-----------------

**E.g. 2**

|Operand|Bits|
|-------------|-------------|
|AL|0110 1110|
|BL|1111 0110|
|Result|0110 0110|

**PF = 1**

*In this case, there's 4 counts of 1 in the result. Therefore the PF is set to 1*

#### Zero Flag (ZF)

Assembly Code

```assembly
test al, bl
jz EvenPar
```


More Reference: https://www.youtube.com/watch?v=2Db-gagWuCc