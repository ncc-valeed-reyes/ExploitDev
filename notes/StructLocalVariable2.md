## StructLocalVariable.c (With Pragma Pack Effect)

### Source Code:

```c
#pragma pack(1)
typedef struct mystruct {
    short a;
    int b[6];
    long long c;
} mystruct_t;
#pragma

short main() {
    mystruct_t foo;
    foo.a = 0xbabe;
    foo.c = 0xba1b0ab1edb100d;
    foo.b[1] = foo.a;
    foo.b[4] = foo.b[1] + foo.c;
    return foo.b[4];
}
```

### Disassembly:

#### Frame 1: StructLocalVariable.exe!main(...)

```assembly
sub rsp, 38h
mov eax, 0FFFFBABEh
mov word ptr [rsp], ax
mov rax, 0BA1B0AB1EDB100Dh
mov qword ptr [rsp+1Ah], rax
mov eax, 4
imul rax, rax, 1
movsx ecx, word ptr [rsp]
mov dword ptr [rsp+rax+2], ecx
mov eax, 4
imul rax, rax, 1
movsxd rax, dword ptr [rsp+rax+2]
add rax, qword ptr [rsp+1Ah]
mov ecx, 4
imul rcx, rcx, 4
mov dword ptr [rsp+rcx+2], eax
mov eax, 4
imul rax, rax, 4
movzx eax, word ptr [rsp+rax+2]
add rsp, 38h
ret
```

## Analyzing the stack (4 bytes)

|Address|Value|
|-------------|-------------|
|0x000000000014FE0C|0000, 0001 -> RETURN ADDRESS to `StructLocalVariable.exe!invoke_main(void)`|
|0x000000000014FE08|4000, 1379 -> RETURN ADDRESS to `StructLocalVariable.exe!invoke_main(void)`|
|0x000000000014FE04|16-byte-stack-alignment-padding|
|0x000000000014FE00|16-byte-alignment-padding|
|0x000000000014FDFC|16-byte-alignment-padding|
|0x000000000014FDF8|16-byte-alignment-padding|
|0x000000000014FDF4|16-byte-alignment-padding|
|0x000000000014FDF0|16-byte-alignment-padding, foo.c MSB 1 = ba1|
|0x000000000014FDEC|foo.c 2 MIDDLE BYTES = b0ab1edb|
|0x000000000014FDE8|foo.c 3 LSB = 100d, foo.b[5] MSB = 1145|
|0x000000000014FDE4|foo.b[5] LSB = 0000, foo.b[4] MSB 2 = 1eda|
|0x000000000014FDE0|foo.b[4] LSB = cacb, foo.b[3] MSB = 0000|
|0x000000000014FDDC|foo.b[3] LSB = 0000, foo.b[2] MSB = 0001|
|0x000000000014FDD8|foo.b[2] LSB = 4000, foo.b[1] MSB 2 = ffff|
|0x000000000014FDD4|foo.b[1] LSB = babe, foo.b[0] MSB = 0001|
|0x000000000014FDD0|foo.b[0] LSB = 0000, foo.a = babe|

## Breaking down each statements

### Frame 1: ArrayLocalVariable.exe!main(...)

`sub rsp, 38h`
 - `rsp`: 000000000014FE08 - 38 = 0x000000000014FDD0

`mov eax, 0FFFFBABEh`
 - Moves 0xFFFFBABE into `rax` register

`mov word ptr [rsp], ax`
 - Moves 0xBABE into `rsp` register

`mov rax, 0BA1B0AB1EDB100Dh`
 - Moves 0xBA1B0AB1EDB100D into `rax` register

`mov qword ptr [rsp+1Ah], rax`
 - Moves 0xBA1B0AB1EDB100D into `rsp` register

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 1`
 - `rax`: 4 * 1 = 4

`movsx ecx, word ptr [rsp]`
 - Moves 0xBABE into `rcx` register and extending it with F's. Keep in mind that this is `ecx` so it would just extend the half of the value which will be 0xFFFFBABE

`mov dword ptr [rsp+rax+2], ecx`
 - Moves 0xFFFFBABE into `rsp` register

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 1`
 - `rax`: 0x4 * 0x1 = 0x4

`movsx rax, dword ptr [rsp+rax+2]`
 - Moves 0x000000000014FDD8 or 0xFFFFBABE into `rax` register and extending the value with F's
 - `rax`: 0xFFFFFFFFFFFFBABE

`add rax, qword ptr [rsp+20h]`
 - Adds 0BA1B0AB1EDB100D and 000000010000babe
 - `rax`: BA1B0AB1EDACACB

`mov ecx, 4`
 - Moves `0x4` into `rcx` register

`imul rcx, rcx, 4`
 - `rax`: 0x4 * 0x4 = 0x10

`mov dword ptr [rsp+rcx+2], eax`
 - Moves 0x1EDACACB into `rsp`

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 4`
 - `rax`: 0x4 * 0x4 = 0x10

`movzx eax, word ptr [rsp+rax+2]`
 - Moves 0xCACB into `rax` register and extending the value with 0's
 - `rax`: 0x00000000000000CACB

`add rsp, 38h`
 - `rsp`: 000000000014FE18 + 38h = 0x000000000014FE08

 `ret`
  - Returns and continues the statement at `ArrayLocalVariable.exe!invoke_main(void)`
  - `rsp`: 000000000014FE08 + 8 = 000000000014FE10

## Notes to keep in mind

`# pragma pack(seq)`
 - this means pack/align into [seq] bytes
 - <http://stackoverflow.com/questions/3318410/ddg#3318475>
 - <https://www.youtube.com/watch?v=8wHoI-6R0CQ>

<hr>