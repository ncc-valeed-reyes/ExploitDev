## BitmaskExample.c

### Source Code:

```c
#include <stdio.h>

int main() {
    int a = 0x1301;
    int b = 0x0100;

    if (a & b) {
        return 0x70dd1e;
    }
    else {
        return 0x707
    }
}
```

### Disassembly:

#### Frame 1: BitmaskExample.exe!func(...)
```assembly
sub rsp, 18h
mov dword ptr [rsp+4], 1301h
mov dword ptr [rsp], 100h
mov eax, dword ptr [rsp]
mov ecx, dword ptr [rsp+4]
and ecx, eax
mov eax, ecx
test eax, eax
je 000000014000102B
mov eax, 70DD1Eh
jmp 0000000140001030
jmp 0000000140001030
mov eax, 707h
add rsp, 18h
ret
```

## Analyzing the stack

### Return address to `BooleanBecause.exe!invoke_main(void)`

|Address|Value|
|-------------|-------------|
|0x000000000014FEEC|00000001|
|0x000000000014FEE8|4000123c|

### 16 byte alignment

|Address|Value|
|-------------|-------------|
|0x000000000014FEE4|00000000|
|0x000000000014FEE0|00000000|
|0x000000000014FEDC|00000000|
|0x000000000014FED8|00000000|

### 1st variable initialized

|Address|Value|
|-------------|-------------|
|0x000000000014FED4|00001301|

### 2nd variable initialized

|Address|Value|
|-------------|-------------|
|0x000000000014FED0|00000100|

### Frame 1: BitmaskExample.exe!main(...)

`sub rsp, 18h`
 - Subracts `rsp` by 18
 - 000000000014FEE8 - 18
 - Address of `rsp`: 000000000014FED0

`mov dword ptr [rsp+4], 1301h`
 - Moves 1301 to `rsp` register with an offset of 4
 - Address of `rsp`: 000000000014FED4
 - Value of `rsp` (4 bytes): 00001301

`mov dword ptr [rsp], 100h`
 - Moves 100 to `rsp` register
 - Address of `rsp`: 000000000014FED0
 - Value of `rsp` (4 bytes): 00000100

`mov eax, dword ptr [rsp]`
 - Moves the `rsp` value into `rax` register
 - Address of `rsp`: 000000000014FED0
 - Value of `rsp`: 00000100
 - New Value of `eax`: 00000100

`mov ecx, dword ptr [rsp+4]`
 - Moves the `rsp` value with an offset of 4 into `rax` register
 - Address of `rsp`: 000000000014FED0
 - Value of `esp`: 00001301
 - New Value of `ecx`: 00001301

`and ecx, eax`
 - Bitwise AND for `eax` and `ecx`
 - 100 AND 1301 = 100
 - Value of `ecx`: 00000100

`mov eax, ecx`
 - Moves the `rcx` value into `rax` register
 - Value of `rcx`: 00000100

`test eax, eax`
 - Compares two both operands

`je 000000014000102B`
 - Jumps to `mov eax, 707h`
 - Jump is not taken, since ZF is not set

`mov eax, 70DD1Eh`
 - Moves 70DD1E into `rax` register

`jmp 0000000140001030`
 - Jumps to the current address -> `add rsp, 18h`

<hr>

*skipped*

`jmp 0000000140001030`
 - Jumps to the current address -> `add rsp, 18h`
 
`mov eax, 707h`
 - Moves 707 into `rax` register

<hr>

`add rsp, 18h`
 - `rsp`: 000000000014FDF0 + 18 = 000000000014FE08

`ret`
  - Returns and continues the statement at `BitmaskExample.exe!invoke_main(void)`
  - `rsp`: 000000000014FEE8 + 8 = 000000000014FEF0

<hr>