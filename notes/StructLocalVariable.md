## StructLocalVariable.c

### Source Code:

```c
// #pragma pack(1)
typedef struct mystruct {
    short a;
    int b[6];
    long long c;
} mystruct_t;
// #pragma

short main() {
    mystruct_t foo;
    foo.a = 0xbabe;
    foo.c = 0xba1b0ab1edb100d;
    foo.b[1] = foo.a;
    foo.b[4] = foo.b[1] + foo.c;
    return foo.b[4];
}
```

### Disassembly:

#### Frame 1: StructLocalVariable.exe!main(...)

```assembly
sub rsp, 48h
mov eax, 0FFFFBABEh
mov word ptr [rsp], ax
mov rax, 0BA1B0AB1EDB100Dh
mov qword ptr [rsp+20h], rax
mov eax, 4
imul rax, rax, 1
movsx ecx, word ptr [rsp]
mov dword ptr [rsp+rax+4], ecx
mov eax, 4
imul rax, rax, 1
movsxd rax, dword ptr [rsp+rax+4]
add rax, qword ptr [rsp+20h]
mov ecx, 4
imul rcx, rcx, 4
mov dword ptr [rsp+rcx+4], eax
mov eax, 4
imul rax, rax, 4
movzx eax, word ptr [rsp+rax+4]
add rsp, 48h
ret
```

## Analyzing the stack (4 Bytes)

|Address|Value|
|-------------|-------------|
|0x000000000014FE08|0000000140001379 -> RETURN ADDRESS to `StructLocalVariable.exe!invoke_main(void)`|
|0x000000000014FE00|16-byte-stack-alignment-padding|
|0x000000000014FDFC|stack-alignment-padding|
|0x000000000014FDF8|stack-alignment-padding|
|0x000000000014FDF4|c(MSB) = 0BA1B0AB|
|0x000000000014FDF0|c(LSB) = 1EDB100D|
|0x000000000014FDEC|struct-alignment-padding|
|0x000000000014FDE8|b[5] = undef|
|0x000000000014FDE4|b[4] = 1EDACACB|
|0x000000000014FDE0|b[3] = undef|
|0x000000000014FDDC|b[2] = undef|
|0x000000000014FDD8|b[1] = FFFFBABE|
|0x000000000014FDD4|b[0] = undef|
|0x000000000014FDD0|padding, a = BABE|

## Breaking down each statements

<i>By setting the breakpoint at `main()`, the current RSP 000000000014FE18 contains an address value which returns back to `ArrayLocalVariable.exe!invoke_main(void)`.</i>

### Frame 1: ArrayLocalVariable.exe!main(...)

`sub rsp, 48h`
 - `rsp`: 000000000014FE18 - 48 = 0x000000000014FDD0

`mov eax, 0FFFFBABEh`
 - Moves 0xFFFFBABE into `rax` register

`mov word ptr [rsp], ax`
 - Moves 0xBABE into `rsp` register or 0x000000000014FDD0

`mov rax, 0BA1B0AB1EDB100Dh`
 - Moves 0xBA1B0AB1EDB100D into `rax` register

`mov qword ptr [rsp+20h], rax`
 - Moves 0xBA1B0AB1EDB100D into `rsp` register or 0x000000000014FDF0

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 1`
 - `rax`: 4 * 1 = 4

`movsx ecx, word ptr [rsp]`
 - Moves 0xBABE into `rcx` register and extending it with F's. Keep in mind that this is `ecx` so it would just extend the half of the value which will be 0xFFFFBABE

`mov dword ptr [rsp+rax+4], ecx`
 - Moves 0xFFFFBABE into `rsp` register or 0x000000000014FDD8

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 1`
 - `rax`: 0x4 * 0x1 = 0x4

`movsx rax, dword ptr [rsp+rax+4]`
 - Moves 0x000000000014FDD8 or 0xFFFFBABE into `rax` register and extending the value with F's
 - `rax`: 0xFFFFFFFFFFFFBABE

`add rax, qword ptr [rsp+20h]`
 - Adds 0BA1B0AB1EDB100D and 000000010000babe
 - `rax`: BA1B0AB1EDACACB

`mov ecx, 4`
 - Moves `0x4` into `rcx` register

`imul rcx, rcx, 4`
 - `rax`: 0x4 * 0x4 = 0x10

`mov dword ptr [rsp+rcx+4], eax`
 - Moves 0x1EDACACB into `rsp` or `0x000000000014FDF0`
 - 0x000000000014FDE4

`mov eax, 4`
 - Moves 0x4 into rax register

`imul rax, rax, 4`
 - `rax`: 0x4 * 0x4 = 0x10

`movzx eax, word ptr [rsp+rax+4]`
 - Moves 0xCACB into `rax` register and extending the value with 0's
 - `rax`: 0x00000000000000CACB

`add rsp, 48h`
 - `rsp`: 000000000014FE18 + 48 = 0x000000000014FE08

 `ret`
  - Returns and continues the statement at `ArrayLocalVariable.exe!invoke_main(void)`
  - `rsp`: 000000000014FE08 + 8 = 000000000014FE10
<hr>

## Notes to keep in mind

MS' struct alignment & padding rules here: <https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions?view=msvc-160>

<hr>