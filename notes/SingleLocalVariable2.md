## SingleLocalVarable2.c

### Source Code:

```c
int func3() {
	int i = 0x7a11;
	return i;
}

int func2() {
	int j = 0x7a1e;
	return func3();
}

int func() {
	return func2();
}

int main() {
	return func();
}
```

### Disassembly:

#### SingleLocalVariable2.exe!func3(...)

```assembly
sub rsp 18h
mov dword ptr [rsp], 7A11h
mov eax, dword ptr[rsp]
add rsp 18h
ret
```

#### SingleLocalVariable2.exe!func2(...)

```assembly
sub rsp 38h
mov dword ptr [rsp+20], 7A1Eh
call func3 (0000000140001000)
add rsp 38h
ret
```

#### SingleLocalVariable2.exe!func(...)

```assembly
sub rsp, 28h
call func2 (0000000140001020)
add rsp 28h
ret
```

#### SingleLocalVariable2.exe!main(...)

```assembly
sub rsp, 28h
call func (0000000140001040)
add rsp 28h
ret
```


## Analyzing the stack

<i><b>Undef</b> just means that it's a padding/filler in the stack.</i>

|Address|Value|
|-------------|-------------|
|<mark>0x000000000014FE08</mark>|<span style="background-color: blue">0000000140001389</span> -> RETURN ADDRESS to `SingleLocalVariable2.exe!invoke_main(void)`|
|0x000000000014FE00|16-byte-stack-alignment-padding|
|0x000000000014FDF8|undef|
|0x000000000014FDF0|undef|
|0x000000000014FDE8|undef|
|0x000000000014FDE0|undef|
|<mark>0x000000000014FDD8</mark>|<span style="background-color: blue">0000000140001069</span> -> RETURN ADDRESS to `SingleLocalVariable2.exe!main(...)`|
|0x000000000014FDD0|16-byte-stack-alignment-padding|
|0x000000000014FDC8|undef|
|0x000000000014FDC0|undef|
|0x000000000014FDB8|undef|
|0x000000000014FDB0|undef|
|<mark>0x000000000014FDA8</mark>|<span style="background-color: blue">0000000140001049</span> -> RETURN ADDRESS to `SingleLocalVariable2.exe!func(...)`|
|0x000000000014FDA0|16-byte-stack-alignment-padding|
|0x000000000014FD98|16-byte-stack-alignment-padding|
|<mark>0x000000000014FD90</mark>|<span style="background-color: green">0x7a1e</span>|
|0x000000000014FD88|undef|
|0x000000000014FD80|undef|
|0x000000000014FD78|undef|
|0x000000000014FD70|undef|
|<mark>0x000000000014FD68</mark>|<span style="background-color: blue">0000000140001031</span> -> RETURN ADDRESS to `SingleLocalVariable2.exe!func2(...)`|
|0x000000000014FD60|16-byte-stack-alignment-padding|
|0x000000000014FD58|16-byte-stack-alignment-padding|
|<mark>0x000000000014FD50</mark>|<span style="background-color: green">0x7a11</span>|


## Breaking down each statements

<i>By setting the breakpoint at `main()`, the current RSP <mark>000000000014FE08</mark> contains a return address which goes back to `SingLocalVariable1.exe!invoke_main(void)`. Just to remind to make it less confusing.</i>


### Frame 1: SingleLocalVariable2.exe!main(...)

`sub rsp 28h` - 000000000014FE08 - 28
 -  `rsp`: 000000000014FE08 - 28 = <mark>000000000014FDE0</mark>

`call func (0000000140001040)`
 - Proceeds to `SingleLocalVariable.exe2!func(...)`
 - `rsp`: 000000000014FDE0 - 8  = <mark>000000000014FDD8</mark>
 - Adds a return address on <mark>000000000014FDD8</mark>

`add rsp 28h`
 - `rsp`: 000000000014FDE0 + 28 = <mark>000000000014FE08</mark>

 `ret`
  - Returns and continues the statement at `SingleLocalVariable.exe2!invoke_main(void)`
  - `rsp`: 000000000014FE08 + 8 = <mark>000000000014FE10</mark>
<hr>

### Frame 2: SingleLocalVariable2.exe!func(...)

`sub rsp 28h`
 - `rsp`: 000000000014FDD8 - 28 = <mark>000000000014FDB0</mark>

`call func (0000000140001040)`
 - Proceeds to `SingleLocalVariable.exe2!func2(...)`
 - Adds a return address on <mark>000000000014FDA8</mark>
 - `rsp`: 000000000014FDB0 - 8  = <mark>000000000014FDA8</mark>

`add rsp 28h`
 - `rsp`: 000000000014FDB0 + 28 = <mark>000000000014FDD8</mark>

 `ret`
  - Exits / goes back to where the statement is at
  - Returns and continues the statement at `SingleLocalVariable2.exe!main(void)`
  - `rsp`: 000000000014FDD8 + 8 = <mark>000000000014FDE0</mark>
<hr>

### Frame 3: SingleLocalVariable2.exe!func2(...)

`sub rsp, 38h`
 - `rsp`: 000000000014FDA8 - 38 = <mark>000000000014FD70</mark>

`mov dword ptr [rsp+20], 7A1Eh`
 - Moves `0x7A1E` into `000000000014FD90`

`call func3 (0000000140001000)`
 - Proceeds to `SingleLocalVariable2.exe!func3(...)`
 - `rsp`: 000000000014FD70 - 8  = <mark>000000000014FD68</mark>
 - Adds a return address on <mark>000000000014FD68</mark>
 
`add rsp, 38h`
 - `rsp`: 000000000014FD70 + 38  = <mark>000000000014FDA8</mark>

 `ret`
  - Returns and continues the statement at `SingleLocalVariable2.exe!func(void)`
  - `rsp`: 000000000014FDA8 + 8 = <mark>000000000014FDB0</mark>
<hr>

### Frame 4: SingleLocalVariable2.exe!func3(...)

`sub rsp 18h`
 - `rsp`: 000000000014FD68 - 18  = <mark>000000000014FD50</mark>

`mov dword ptr [rsp], 7A11h`
 - Moves 0x7A11 to `000000000014FD50`

`mov eax, dword ptr[rsp]`
 - Moves the value of rsp or `000000000014FDA0` into `rax`

`add rsp 18h`
 - `rsp`: 000000000014FD50 + 18  = <mark>000000000014FD68</mark>

 `ret`
  - Returns and continues the statement at `SingleLocalVariable2.exe!func2(void)`
  - `rsp`: 000000000014FD68 + 8 = <mark>000000000014FD70</mark>
<hr>

## Notes to keep in mind

<https://docs.microsoft.com/en-us/cpp/build/stack-usage?view=msvc-160>

 - The stack will always be maintained 16-byte aligned, except within the prolog (for example, after the return address is pushed)


<hr>