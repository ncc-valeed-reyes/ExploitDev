## TooManyParameters.c

### Source Code:

```c
#define data int

int func(data a, data b, data c, data d, data e) {
    int i = a+b-c+d-e;
	return i;
}

int main() {
    return func(0x11, 0x22, 0x33, 0x44, 0x55);
}
```

### Disassembly:

#### Frame 1: TooManyParameters.exe!func(...)
```assembly
push ebp
mov ebp, esp
push ecx
mov eax, dword ptr [ebp+8]
add eax, dword ptr [ebp+0ch]
sub eax, dword ptr [ebp+10h]
add eax, dword ptr [ebp+14h]
sub eax, dword ptr [ebp+18h]
mov dword ptr [ebp-4], eax
mov eax, dword ptr [ebp-4]
mov esp, ebp
pop ebp
ret
```

#### Frame 2: TooManyParameters.exe!main(...)
```assembly
push ebp
mov ebp, esp
push 55h
push 44h
push 33h
push 22h
push 11h
call 00401000
add esp, 14h
pop ebp
ret
```

## Analyzing the stack

|Address|Value|
|-------------|-------------|
|0x0019FEE8|004013b3 -> RETURN ADDRESS to `TooManyParameters.exe!invoke_main(void)`|
|0x0019FEE4|0019FF04 -> Saved previous `ebp`|
|0x0019FEE0|00000055 -> 5th parameter value from func()|
|0x0019FEDC|00000044 -> 4th parameter value from func()|
|0x0019FED8|00000033 -> 3rd parameter value from func()|
|0x0019FED4|00000022 -> 2nd parameter value from func()|
|0x0019FED0|00000011 -> 1st parameter value from func()|
|0x0019FECC|00401032 -> RETURN ADDRESS to `TooManyParameters.exe!main(void)`|
|0x0019FEC8|0019FEE4 -> Saved previous `ebp`|
|0x0019FEC4|FFFFFFEF -> a+b-c+d-e|

## Breaking down each statements

Current `esp`: 0019FEE8

### Frame 1: TooManyParameters.exe!main(...)

`push ebp`
 - Subracts `esp` by 4
 - 0019FEE8 - 4
 - Address of `esp`: 0019FEE4
 - Value of `esp`: 0019FF04

`mov ebp, esp`
 - Moves `esp` address into `ebp` register
 - Value of `ebp`: 0019FEE4

`push 55h`
 - Subracts `esp` by 4
 - 0019FEE4 - 4
 - Address of `esp`: 0019FEE0
 - Value of `esp`: 00000055

`push 44h`
 - Subracts `esp` by 4
 - 0019FEE0 - 4
 - Address of `esp`: 0019FEDC
 - Value of `esp`: 00000044

`push 33h`
 - Subracts `esp` by 4
 - 0019FEDC - 4
 - Address of `esp`: 0019FED8
 - Value of `esp`: 00000033

`push 22h`
 - Subracts `esp` by 4
 - 0019FED8 - 4
 - Address of `esp`: 0019FED4
 - Value of `esp`: 00000022

`push 11h`
 - Subracts `esp` by 4
 - 0019FED4 - 4
 - Address of `esp`: 0019FED0
 - Value of `esp`: 00000011

`call 00401000`
 - Subracts `esp` by 4
 - 0019FED0 - 4
 - Address of `esp`: 0019FECC
 - Value of `esp`: 00401032
 - Proceeds to `TooManyParameters.exe!func(int, int, int, int, int)`

`add esp, 14h`
 - Adds esp by 14
 - 0019FECC + 14
 - Address of `esp`: 0019FEE4
 - Value of `esp`: 0019FF04

`pop ebp`
 - Adds `esp` by 4
 - 0019FEE4 + 4
 - Address of `esp`: 0019FEE8
 - Value of `esp`: 004013b3
 - Moves the `esp` value into `ebp` register

`ret`
 - Returns and continues the statement at `Pass1Parameter.exe!main(...)`
 - Adds `esp` by 4
 - 0019FEE8 + 4
 - Address of `esp`: 0019FEEC
 - Value of `esp`: 00000001
<hr>

### Frame 2: TooManyParameters.exe!func(int, int, int, int, int)

`push ebp`
 - Subracts `esp` by 4
 - 0019FECC - 4
 - Address of `esp`: 0019FEC8
 - Value of `esp`: 0019fEE4

`mov ebp, esp`
 - Moves `esp` address into `ebp` register
 - Value of `ebp`: 0019FEC8

`push ecx`
 - Pushes ecx into the value of `esp` register
 - Subracts `esp` by 4
 - 0019FEC8 - 4
 - Address of `esp`: 0019FEC4
 - Value of `esp`: 00000001

`mov eax, dword ptr [ebp+8]`
 - Moves the ebp value into `eax` register
 - 0019FEC8 + 8
 - Address of `ebp`: 0019FED0
 - Value of `eax`: 00000001

`add eax, dword ptr [ebp+0ch]`
 - Adds the ebp value into `eax` register
 - 0019FEC8 + 0c
 - Address of `ebp`: 0019FED4
 - Value of `ebp`: 00000022
 - Value of `eax`: 00000011
 - New Value of `eax`: 00000033

`sub eax, dword ptr [ebp+10h]`
 - Subtracts the ebp value into `eax` register
 - 0019FEC8 + 10
 - Address of `ebp`: 0019FED8
 - Value of `ebp`: 00000033
 - Value of `eax`: 00000033
 - New Value of `eax`: 00000000

`add eax, dword ptr [ebp+14h]`
 - Adds the ebp value into `eax` register
 - 0019FEC8 + 14
 - Address of `ebp`: 0019FEDC
 - Value of `ebp`: 00000044
 - Value of `eax`: 00000000
 - New Value of `eax`: 00000044
 
`sub eax, dword ptr [ebp+18h]`
 - Adds the ebp value into `eax` register
 - 0019FEC8 + 18
 - Address of `ebp`: 0019FEE0
 - Value of `ebp`: 00000055
 - Value of `eax`: 00000044
 - New Value of `eax`: FFFFFFEF

`mov dword ptr [ebp-4], eax`
 - Moves the `eax` value into `ebp` register
 - Value of `eax`: FFFFFFEF
 - 0019FEC8 - 4
 - Address of `ebp`: 0019FEC4
 - Value of `ebp`: FFFFFFEF

`mov eax, dword ptr [ebp-4]`
 - Moves the `ebp` value into `eax` register

`mov esp, ebp`
 - Moves the `esp` value into `ebp` register

`pop ebp`
 - Adds `esp` by 8
 - 0019FEC4 + 8
 - Address of `esp`: 0019FECC
 - Value of `esp`: 00401032
 - Moves the `esp` value into `ebp` register

`ret`
 - Returns and continues the statement at `Pass1Parameter.exe!main(...)`
 - Adds `esp` by 4
 - 0019FECC + 4
 - Address of `esp`: 0019FED0
 - Value of `esp`: 00000011

## Notes to keep in mind

In 32-bit x86 architecture, the base pointer (ebp) is commonly used as a frame pointer for referencing local variables and function parameters on the stack. When you see instructions like mov, add, or sub with [ebp+<something>], it typically means you are accessing memory relative to the base pointer.

In 64-bit x86 architecture, the base pointer (ebp) is not commonly used as a frame pointer due to optimizations in the calling conventions. Instead, the stack pointer (rsp) is often used to reference stack-based data. This change was made to simplify and speed up function calls and improve performance.

So, in 64-bit code, you will often see instructions like mov, add, or sub with [rsp+<something>] to access memory relative to the stack pointer. This change in convention is one of the differences between 32-bit and 64-bit x86 architectures.

Each time you enter a new function, the old ebp gets pushed onto the stack, and the new esp gets moved into ebp.

<hr>